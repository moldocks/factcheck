% ================== GARCH-Based Backtesting Script with Trendline Filter ==================

% PART 0: Load and Preprocess Data
% -------------------------------------------------------------------------
clear;  % Clear all variables from the workspace
clc;    % Clear the command window

% Load data
try
    dataFilePath = 'C:/Users/Fujitsu/Downloads/EURUSD_Candlestick_1_D_BID_06.01.2007-31.12.2018.csv';
    opts = detectImportOptions(dataFilePath);
    opts.VariableNamingRule = 'preserve';  % Preserve original column headers
    data = readtable(dataFilePath, opts);
catch
    error('Error loading the data file. Please ensure the file exists and the path is correct.');
end

% Convert the DateTime column to MATLAB datetime (including time)
try
    data.Datetime = datetime(data.Datetime, 'InputFormat', 'dd.MM.yyyy HH:mm:ss');
catch
    error('Error in datetime conversion. Please ensure the datetime format is correct.');
end

% Clean the data by removing rows with zero volume and handling missing data
cleaned_data = data(data.Volume > 0, :);
cleaned_data = rmmissing(cleaned_data); % Remove rows with missing values

% Extract necessary columns for calculations
opens = cleaned_data.Open;
closes = cleaned_data.Close;
highs = cleaned_data.High;
lows = cleaned_data.Low;
volumes = cleaned_data.Volume;  % Volume column

% PART 1: Ensure the lengths of arrays are aligned
% -------------------------------------------------------------------------
minLength = height(cleaned_data);
opens = opens(1:minLength);
closes = closes(1:minLength);
highs = highs(1:minLength);
lows = lows(1:minLength);
volumes = volumes(1:minLength);

% PART 2: Rolling GARCH(1,1) Volatility Estimation
% -------------------------------------------------------------------------
if minLength > 50  % Ensure there are enough data points for GARCH estimation
    returns = diff(log(closes));  % Calculate log returns
    garchModel = garch(1, 1);      % Specify the GARCH(1,1) model
    
    garchWindow = 750;  % Define the rolling window size for GARCH estimation
    garchVolatility = NaN(size(returns));  % Initialize the GARCH volatility array

    for i = garchWindow:length(returns)
        returnsWindow = returns(i - garchWindow + 1:i);
        try
            [estModel, ~, ~] = estimate(garchModel, returnsWindow, 'Display', 'off');
            [v, ~] = infer(estModel, returnsWindow);
            garchVolatility(i) = sqrt(v(end));
        catch
            garchVolatility(i) = NaN;
        end
    end

    garchVolatility = [NaN; garchVolatility];
else
    error('Not enough data points for GARCH estimation.');
end

% PART 3: Define Lookback Period for Z-score and Calculate Moving Average
% -------------------------------------------------------------------------
lookback = 20;
movingAvg = movmean(closes, [lookback-1, 0]);
movingStd = movstd(closes, [lookback-1, 0]);

% Calculate Z-score
zScore = (closes - movingAvg) ./ movingStd;
zScore = zScore(1:minLength);

% PART 4: Initialize Variables for Volatility Regimes and Thresholds
% -------------------------------------------------------------------------
volatilityRegimes = zeros(size(closes));
zScore_Entry_Exit = zeros(length(closes), 2);

low_vol_thresholds = [-0.5, 0.5];
med_vol_thresholds = [-1.0, 1.0];
high_vol_thresholds = [-1.2, 1.2];

% PART 5: Calculate Average True Range (ATR)
% -------------------------------------------------------------------------
atrLookback = 14;
atr = movmean(highs - lows, [atrLookback-1, 0]);

% PART 6: Apply the Best SL/TP from Grid Search and Set TP Using GARCH Volatility
% -------------------------------------------------------------------------
low_sl_multiplier = 2;  % Keep using the SL based on ATR
med_sl_multiplier = 1.5; 
high_sl_multiplier = 2;

TP_multiplier = 2.0;  % Use GARCH volatility for TP, adjustable multiplier

% PART 7: Trendline Calculation Using Swing Highs and Lows
% -------------------------------------------------------------------------
swingHighs = islocalmax(highs, 'MinSeparation', lookback); % Detect swing highs using past data
swingLows =  islocalmin(lows, 'MinSeparation', lookback);   % Detect swing lows using past data

trendDirection = NaN(minLength, 1);  % 1 for uptrend, -1 for downtrend, NaN for no trend

for i = lookback+1:minLength
    if swingHighs(i-1)
        trendDirection(i) = -1;  % Downtrend
    elseif swingLows(i-1)
        trendDirection(i) = 1;   % Uptrend
    else
        trendDirection(i) = NaN; % No clear trend
    end
end

% PART 8: Initialize Backtesting Variables
% -------------------------------------------------------------------------
signalDetails = cell(0, 11);  % Initialize empty cell array
totalPipsGained = 0;
totalPipsLost = 0;
winningTrades = 0;
losingTrades = 0;
consecStopLossHits = 0;
maxConsecStopLossHits = 0;
isPositionOpen = false;  % Flag to track if a position is currently open
positionType = '';  % Store the type of the current position ('Long Entry' or 'Short Entry')
entryPrice = 0;
stopLossPrice = 0;
profitTargetPrice = 0;
tradeReturns = [];  % Initialize the array to track returns

% PART 9: Main Backtesting Loop (with Trend Filter and Pinbar/Engulfing Entry)
% -------------------------------------------------------------------------
logVolumeChange = [NaN; log(volumes(2:end) ./ volumes(1:end-1))];

% Start the loop from the maximum of lookbacks to ensure all variables are valid
startIndex = max([atrLookback, lookback, garchWindow]) + 1;

for i = startIndex:minLength
    allowLongTrade = trendDirection(i) == 1;
    allowShortTrade = trendDirection(i) == -1;

    % Exit logic if position is open
    if isPositionOpen
        if strcmp(positionType, 'Long Entry')
            if lows(i) <= stopLossPrice  % Stop loss hit for long position
                exitPrice = stopLossPrice;
                exitReason = 'Exit by Stop Loss';
                consecStopLossHits = consecStopLossHits + 1;
            elseif highs(i) >= profitTargetPrice  % Profit target hit for long position
                exitPrice = profitTargetPrice;
                exitReason = 'Exit by Profit Target';
                consecStopLossHits = 0;
            else
                continue;
            end
        elseif strcmp(positionType, 'Short Entry')
            if highs(i) >= stopLossPrice  % Stop loss hit for short position
                exitPrice = stopLossPrice;
                exitReason = 'Exit by Stop Loss';
                consecStopLossHits = consecStopLossHits + 1;
            elseif lows(i) <= profitTargetPrice  % Profit target hit for short position
                exitPrice = profitTargetPrice;
                exitReason = 'Exit by Profit Target';
                consecStopLossHits = 0;
            else
                continue;
            end
        end

        % Record trade outcome
        tradePips = (exitPrice - entryPrice) * 10000;
        if strcmp(positionType, 'Short Entry')
            tradePips = -tradePips;  % Reverse calculation for short trades
        end

        % Record return for Sharpe ratio calculation
        tradeReturns(end + 1) = tradePips;

        if strcmp(exitReason, 'Exit by Stop Loss')
            totalPipsLost = totalPipsLost + abs(tradePips);  % Always record as loss when SL hit
            losingTrades = losingTrades + 1;
        elseif strcmp(exitReason, 'Exit by Profit Target')
            totalPipsGained = totalPipsGained + tradePips;
            winningTrades = winningTrades + 1;
        end

        % Update the maximum consecutive stop-loss hits
        if consecStopLossHits > maxConsecStopLossHits
            maxConsecStopLossHits = consecStopLossHits;
        end

        % Record exit details and trade outcome
        signalDetails{end, 7} = exitReason;
        signalDetails{end, 8} = datestr(cleaned_data.Datetime(i));
        signalDetails{end, 9} = exitPrice;
        signalDetails{end, 10} = true;
        signalDetails{end, 11} = profitTargetPrice;

        % Close the position
        isPositionOpen = false;
        positionType = '';
        continue;
    end

% Entry logic for Long positions based on Z-score and Pinbar/Engulfing patterns
    if ~isPositionOpen && zScore(i) <= zScore_Entry_Exit(i, 1) && logVolumeChange(i) >= 0.5 && allowLongTrade
        % Long entry logic (bullish pin bar or engulfing)
        signalIndex = i;
        signalType = 'Long Entry';
        entryPrice = opens(signalIndex + 1);

        % Adjust stop-loss based on ATR and profit target based on GARCH volatility
        if volatilityRegimes(i) == 1  % Low volatility
            stopLossDistance = low_sl_multiplier * atr(i);  % SL based on ATR
        elseif volatilityRegimes(i) == 2  % Medium volatility
            stopLossDistance = med_sl_multiplier * atr(i);  % SL based on ATR
        else  % High volatility
            stopLossDistance = high_sl_multiplier * atr(i);  % SL based on ATR
        end

        % Use GARCH volatility to determine profit target distance
        profitTargetDistance = TP_multiplier * garchVolatility(i);  % TP based on GARCH volatility

        stopLossPrice = entryPrice - stopLossDistance;
        profitTargetPrice = entryPrice + profitTargetDistance;

        % Record entry details
        signalDetails(end+1, :) = {signalType, 'Bullish Pin Bar/Engulfing', datestr(cleaned_data.Datetime(signalIndex)), entryPrice, ...
                                   [num2str(stopLossDistance), ' pips'], stopLossDistance, '', '', NaN, true, profitTargetPrice};

        isPositionOpen = true;
        positionType = 'Long Entry';
    end

    % Entry logic for Short positions based on Z-score and Pinbar/Engulfing patterns
    if ~isPositionOpen && zScore(i) >= zScore_Entry_Exit(i, 2) && logVolumeChange(i) >= 0.5 && allowShortTrade
        % Short entry logic (bearish pin bar or engulfing)
        signalIndex = i;
        signalType = 'Short Entry';
        entryPrice = opens(signalIndex + 1);

        % Adjust stop-loss based on ATR and profit target based on GARCH volatility
        if volatilityRegimes(i) == 1  % Low volatility
            stopLossDistance = low_sl_multiplier * atr(i);  % SL based on ATR
        elseif volatilityRegimes(i) == 2  % Medium volatility
            stopLossDistance = med_sl_multiplier * atr(i);  % SL based on ATR
        else  % High volatility
            stopLossDistance = high_sl_multiplier * atr(i);  % SL based on ATR
        end

        % Use GARCH volatility to determine profit target distance
        profitTargetDistance = TP_multiplier * garchVolatility(i);  % TP based on GARCH volatility

        stopLossPrice = entryPrice + stopLossDistance;
        profitTargetPrice = entryPrice - profitTargetDistance;

        % Record entry details
        signalDetails(end+1, :) = {signalType, 'Bearish Pin Bar/Engulfing', datestr(cleaned_data.Datetime(signalIndex)), entryPrice, ...
                                   [num2str(stopLossDistance), ' pips'], stopLossDistance, '', '', NaN, true, profitTargetPrice};

        isPositionOpen = true;
        positionType = 'Short Entry';
    end
end

% PART 9: Display Final Results
% -------------------------------------------------------------------------
% Convert signalDetails to a table
signalTable = cell2table(signalDetails, 'VariableNames', ...
    {'SignalType', 'PatternType', 'EntryTime', 'EntryPrice', 'StopLossPrice', 'StopLossInPips', ...
     'ExitReason', 'ExitTime', 'ExitPrice', 'AAATrade', 'ProfitTargetPrice'});

disp(signalTable);

% Recalculate Total Trades
totalTrades = winningTrades + losingTrades;

% Winning Percentage Calculation
if totalTrades > 0
    winPercentage = (winningTrades / totalTrades) * 100;
    disp(['Winning Percentage: ', num2str(winPercentage), '%']);
else
    disp('No trades executed, cannot calculate winning percentage.');
end

% Recalculate Expectancy
if totalTrades > 0
    expectancy = (totalPipsGained - totalPipsLost) / totalTrades;
    disp(['Expectancy: ', num2str(expectancy), ' pips per trade']);
else
    disp('No trades executed, cannot calculate expectancy.');
end

% Sharpe Ratio Calculation
if length(tradeReturns) > 1
    tradeStdDev = std(tradeReturns);
    avgReturnPerTrade = mean(tradeReturns);
    sharpeRatio = avgReturnPerTrade / tradeStdDev;
    disp(['Sharpe Ratio: ', num2str(sharpeRatio)]);
else
    disp('Cannot calculate Sharpe Ratio without variance in trades.');
end

